async function run() {
  try {
    const { parentPort, workerData } = await import('worker_threads');
    let { quality, width, height, format, formattedImageName, file, srcPath } = workerData;
    const { default: fs } = await import('fs');
    const { resolve, join } = (await import('path')).default;
    const imageSrcPath = resolve(join('src', ...srcPath.split('/'), `${file}`));
    const imageDestPath = resolve(join('src', ...srcPath.split('/'), 'formats', format));
    const absoluteDest = resolve(imageDestPath, formattedImageName);
    if (fs.existsSync(absoluteDest)) {
      return;
    }
    if (!fs.existsSync(imageDestPath)) {
      fs.mkdirSync(imageDestPath, { recursive: true });
    }
    const { default: sharp } = await import('sharp');
    sharp.cache(false);
    const pipeline = sharp(imageSrcPath);
    const { width: metaDataWidth, height: metaDataHeight } = await pipeline.metadata();
    if (metaDataWidth && metaDataHeight) {
      width = width && metaDataWidth >= width ? width : null;
      height = height && metaDataHeight >= height ? height : null;
    }
    if (width || height) {
      pipeline.resize(width, height, { fit: 'outside' });
    }
    if (format == 'avif') {
      pipeline.avif({ quality });
    } else if (format == 'webp') {
      pipeline.webp({ quality });
    } else {
      throw new Error('Imagee format is not supported.');
    }
    parentPort.postMessage('outputPath');

    return await pipeline.toFile(absoluteDest);
  } catch (error) {
    console.log(error);
  }
}
await run();
